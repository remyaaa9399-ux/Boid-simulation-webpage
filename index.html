<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Boids Flocking Simulation 1</title>
  <style>
    :root{
      --bg0:#061018; --panel:#0b1620; --accent:#1ea0ff; --muted:#9aa8b2;
      --glass: rgba(255,255,255,0.04);
    }
    html,body{height:100%;margin:0;font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;}
    body{display:flex;gap:20px;background:linear-gradient(180deg,var(--bg0) 0%, #071427 100%);color:#e8f1f8;padding:18px;box-sizing:border-box;}
    .app{display:grid;grid-template-columns:1fr 320px;gap:18px;flex:1;min-height:calc(100vh - 36px);}
    .canvas-wrap{background:var(--panel);border-radius:12px;padding:12px;box-shadow: 0 10px 30px rgba(0,0,0,0.6);display:flex;flex-direction:column;align-items:stretch;}
    canvas{border-radius:8px;background:linear-gradient(180deg, rgba(4,6,10,0.4), rgba(6,10,15,0.6));display:block;width:100%;height:calc(100vh - 120px);touch-action:none;}
    .panel{background:var(--panel);border-radius:12px;padding:14px;min-width:280px;box-shadow: inset 0 1px 0 rgba(255,255,255,0.02);}
    h1{font-size:16px;margin:0 0 8px 0}
    .control{margin-bottom:12px}
    .control label{display:flex;justify-content:space-between;align-items:center;font-size:13px;color:var(--muted);margin-bottom:6px}
    input[type="range"]{width:100%}
    .row{display:flex;gap:8px}
    button{background:var(--accent);border:none;color:white;padding:8px 10px;border-radius:8px;cursor:pointer}
    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
    .small{font-size:12px;color:var(--muted)}
    .top-bar{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
    .badge{background:var(--glass);padding:6px 8px;border-radius:8px;font-size:13px;color:var(--muted)}
    @media (max-width:900px){ .app{grid-template-columns:1fr} canvas{height:60vh} .panel{position:sticky;top:12px} }
  </style>
</head>
<body>
  <div class="app">
    <div class="canvas-wrap">
      <div class="top-bar">
        <h1>Boids — Flocking Simulation (HTML & JS)</h1>
        <div class="badge" id="info">Boids: 120 • Perception: 50</div>
      </div>
      <canvas id="c"></canvas>
      <div class="small" style="margin-top:8px">Tip: Use sliders to discover flocking, milling, or chaotic behavior.</div>
    </div>

    <div class="panel">
      <div style="display:flex;gap:8px;margin-bottom:8px;">
        <button id="resetBtn">Reset</button>
        <button id="pauseBtn" class="ghost">Pause</button>
        <button id="addBtn" class="ghost">+10</button>
        <button id="subBtn" class="ghost">-10</button>
      </div>

      <div class="control">
        <label>Boid count: <strong id="countLabel">120</strong></label>
        <input id="count" type="range" min="10" max="1000" step="1" value="120">
      </div>

      <div class="control">
        <label>Perception radius: <strong id="percLabel">50</strong></label>
        <input id="perception" type="range" min="10" max="200" step="1" value="50">
      </div>

      <div class="control">
        <label>Separation weight: <strong id="sepLabel">1.5</strong></label>
        <input id="separation" type="range" min="0" max="5" step="0.05" value="1.5">
      </div>

      <div class="control">
        <label>Alignment weight: <strong id="alignLabel">1.0</strong></label>
        <input id="alignment" type="range" min="0" max="5" step="0.05" value="1.0">
      </div>

      <div class="control">
        <label>Cohesion weight: <strong id="cohLabel">1.0</strong></label>
        <input id="cohesion" type="range" min="0" max="5" step="0.05" value="1.0">
      </div>

      <div class="control">
        <label>Max speed: <strong id="speedLabel">2.5</strong></label>
        <input id="maxSpeed" type="range" min="0.2" max="8" step="0.1" value="2.5">
      </div>

      <div class="control">
        <label>Max force: <strong id="forceLabel">0.05</strong></label>
        <input id="maxForce" type="range" min="0.001" max="0.5" step="0.001" value="0.05">
      </div>

      <div style="display:flex;gap:10px;align-items:center;margin-top:6px;margin-bottom:10px">
        <label style="display:flex;align-items:center;gap:8px;">
          <input id="trails" type="checkbox" checked> <span class="small">Trails</span>
        </label>

        <label style="display:flex;align-items:center;gap:8px;">
          <input id="vectors" type="checkbox"> <span class="small">Show velocity</span>
        </label>
      </div>

      <div style="margin-top:8px" class="small">Export: <button id="png" class="ghost">PNG</button></div>
    </div>
  </div>

<script>
(() => {
  // Canvas & scaling
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  function resize() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.floor(canvas.clientWidth * dpr);
    canvas.height = Math.floor(canvas.clientHeight * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener('resize', resize);
  resize();

  // Controls
  const control = {
    count: document.getElementById('count'),
    countLabel: document.getElementById('countLabel'),
    perception: document.getElementById('perception'),
    percLabel: document.getElementById('percLabel'),
    separation: document.getElementById('separation'),
    sepLabel: document.getElementById('sepLabel'),
    alignment: document.getElementById('alignment'),
    alignLabel: document.getElementById('alignLabel'),
    cohesion: document.getElementById('cohesion'),
    cohLabel: document.getElementById('cohLabel'),
    maxSpeed: document.getElementById('maxSpeed'),
    speedLabel: document.getElementById('speedLabel'),
    maxForce: document.getElementById('maxForce'),
    forceLabel: document.getElementById('forceLabel'),
    trails: document.getElementById('trails'),
    vectors: document.getElementById('vectors'),
    pauseBtn: document.getElementById('pauseBtn'),
    resetBtn: document.getElementById('resetBtn'),
    addBtn: document.getElementById('addBtn'),
    subBtn: document.getElementById('subBtn'),
    pngBtn: document.getElementById('png'),
    info: document.getElementById('info')
  };

  // Live label updates
  function refreshLabels() {
    control.countLabel.textContent = control.count.value;
    control.percLabel.textContent = control.perception.value;
    control.sepLabel.textContent = parseFloat(control.separation.value).toFixed(2);
    control.alignLabel.textContent = parseFloat(control.alignment.value).toFixed(2);
    control.cohLabel.textContent = parseFloat(control.cohesion.value).toFixed(2);
    control.speedLabel.textContent = parseFloat(control.maxSpeed.value).toFixed(1);
    control.forceLabel.textContent = parseFloat(control.maxForce.value).toFixed(3);
    control.info.textContent = `Boids: ${control.count.value} • Perception: ${control.perception.value}`;
  }
  ['input','change'].forEach(ev => {
    [control.count, control.perception, control.separation, control.alignment, control.cohesion, control.maxSpeed, control.maxForce]
      .forEach(el => el.addEventListener(ev, refreshLabels));
  });
  refreshLabels();

  // Utility vector helpers
  function mag(v){ return Math.hypot(v.x, v.y); }
  function setMag(v, m){
    const d = Math.hypot(v.x, v.y) || 1e-9;
    v.x = v.x/d * m; v.y = v.y/d * m;
  }
  function limit(v, max){
    const m = Math.hypot(v.x, v.y);
    if(m > max){ v.x = v.x/m * max; v.y = v.y/m * max; }
  }

  // Boid class
  class Boid {
    constructor(x,y){
      this.pos = {x,y};
      const a = Math.random() * Math.PI*2;
      this.vel = {x: Math.cos(a)*(Math.random()*1.5+0.2), y: Math.sin(a)*(Math.random()*1.5+0.2)};
      this.acc = {x:0,y:0};
      this.r = 4;
    }
    applyForce(f){ this.acc.x += f.x; this.acc.y += f.y; }
    edges(w,h){
      if(this.pos.x > w) this.pos.x = 0;
      if(this.pos.x < 0) this.pos.x = w;
      if(this.pos.y > h) this.pos.y = 0;
      if(this.pos.y < 0) this.pos.y = h;
    }
    update(maxSpeed){
      this.vel.x += this.acc.x; this.vel.y += this.acc.y;
      limit(this.vel, maxSpeed);
      this.pos.x += this.vel.x; this.pos.y += this.vel.y;
      this.acc.x = 0; this.acc.y = 0;
    }
    draw(ctx, showVectors){
      // draw triangle pointing in velocity direction
      const theta = Math.atan2(this.vel.y, this.vel.x);
      ctx.save();
      ctx.translate(this.pos.x, this.pos.y);
      ctx.rotate(theta);
      ctx.beginPath();
      ctx.moveTo(this.r*2, 0);
      ctx.lineTo(-this.r*1.2, this.r);
      ctx.lineTo(-this.r*1.2, -this.r);
      ctx.closePath();
      ctx.fillStyle = 'rgba(30,160,255,0.95)';
      ctx.fill();
      ctx.restore();
      if(showVectors){
        ctx.beginPath();
        ctx.moveTo(this.pos.x, this.pos.y);
        ctx.lineTo(this.pos.x + this.vel.x*6, this.pos.y + this.vel.y*6);
        ctx.strokeStyle = 'rgba(255,90,90,0.6)';
        ctx.stroke();
      }
    }
    flock(boids, params){
      const perception = params.perception;
      let total = 0;
      const align = {x:0,y:0};
      const coh = {x:0,y:0};
      const sep = {x:0,y:0};
      for(const other of boids){
        if(other === this) continue;
        const dx = other.pos.x - this.pos.x;
        const dy = other.pos.y - this.pos.y;
        const d = Math.hypot(dx,dy);
        if(d < perception && d > 0){
          align.x += other.vel.x; align.y += other.vel.y;
          coh.x += other.pos.x; coh.y += other.pos.y;
          // separation: stronger when closer
          sep.x += (this.pos.x - other.pos.x) / (d * d + 0.0001);
          sep.y += (this.pos.y - other.pos.y) / (d * d + 0.0001);
          total++;
        }
      }
      if(total > 0){
        // alignment
        align.x /= total; align.y /= total;
        setMag(align, params.maxSpeed);
        align.x -= this.vel.x; align.y -= this.vel.y;
        limit(align, params.maxForce);
        // cohesion (steer toward average position)
        coh.x /= total; coh.y /= total;
        coh.x -= this.pos.x; coh.y -= this.pos.y;
        setMag(coh, params.maxSpeed);
        coh.x -= this.vel.x; coh.y -= this.vel.y;
        limit(coh, params.maxForce);
        // separation
        sep.x /= total; sep.y /= total;
        limit(sep, params.maxForce * 5);

        // weights
        align.x *= params.alignWeight; align.y *= params.alignWeight;
        coh.x *= params.cohWeight; coh.y *= params.cohWeight;
        sep.x *= params.sepWeight; sep.y *= params.sepWeight;

        this.applyForce(align);
        this.applyForce(coh);
        this.applyForce(sep);
      }
    }
  }

  // Simulation state
  let boids = [];
  let running = true;
  let raf = null;

  function initBoids(n){
    boids = [];
    const w = canvas.clientWidth, h = canvas.clientHeight;
    for(let i=0;i<n;i++){
      boids.push(new Boid(Math.random()*w, Math.random()*h));
    }
  }

  function paramsFromControls(){
    return {
      perception: Number(control.perception.value),
      sepWeight: Number(control.separation.value),
      alignWeight: Number(control.alignment.value),
      cohWeight: Number(control.cohesion.value),
      maxSpeed: Number(control.maxSpeed.value),
      maxForce: Number(control.maxForce.value)
    };
  }

  // expose small compatibility for flock method
  // map control names to shorter param names used inside flock
  Object.defineProperty(Boid.prototype, 'flock', {
    value: function(boidsArr){
      const p = paramsFromControls();
      // rename weights for usage
      const params = {
        perception: p.perception,
        sepWeight: p.sepWeight,
        alignWeight: p.alignWeight,
        cohWeight: p.cohWeight,
        maxSpeed: p.maxSpeed,
        maxForce: p.maxForce
      };
      // the original method expects those param names; call internal logic
      // We'll just reuse the flock implementation above by copying it here to avoid indirection.
      const perception = params.perception;
      let total = 0;
      const align = {x:0,y:0};
      const coh = {x:0,y:0};
      const sep = {x:0,y:0};
      for(const other of boidsArr){
        if(other === this) continue;
        const dx = other.pos.x - this.pos.x;
        const dy = other.pos.y - this.pos.y;
        const d = Math.hypot(dx,dy);
        if(d < perception && d > 0){
          align.x += other.vel.x; align.y += other.vel.y;
          coh.x += other.pos.x; coh.y += other.pos.y;
          sep.x += (this.pos.x - other.pos.x) / (d * d + 0.0001);
          sep.y += (this.pos.y - other.pos.y) / (d * d + 0.0001);
          total++;
        }
      }
      if(total > 0){
        align.x /= total; align.y /= total;
        setMag(align, params.maxSpeed);
        align.x -= this.vel.x; align.y -= this.vel.y;
        limit(align, params.maxForce);

        coh.x /= total; coh.y /= total;
        coh.x -= this.pos.x; coh.y -= this.pos.y;
        setMag(coh, params.maxSpeed);
        coh.x -= this.vel.x; coh.y -= this.vel.y;
        limit(coh, params.maxForce);

        sep.x /= total; sep.y /= total;
        limit(sep, params.maxForce * 5);

        // weights
        align.x *= params.alignWeight; align.y *= params.alignWeight;
        coh.x *= params.cohWeight; coh.y *= params.cohWeight;
        sep.x *= params.sepWeight; sep.y *= params.sepWeight;

        this.applyForce(align);
        this.applyForce(coh);
        this.applyForce(sep);
      }
    }
  });

  // Animation loop
  function animate(){
    if(!running) return;
    raf = requestAnimationFrame(animate);
    if(!control.trails.checked){
      ctx.clearRect(0,0,canvas.clientWidth, canvas.clientHeight);
      // nice background
      ctx.fillStyle = '#05111a';
      ctx.fillRect(0,0,canvas.clientWidth, canvas.clientHeight);
    } else {
      // soft fade for trails
      ctx.fillStyle = 'rgba(7,10,12,0.12)';
      ctx.fillRect(0,0,canvas.clientWidth, canvas.clientHeight);
    }

    const p = paramsFromControls();
    // update each boid
    for(const b of boids){
      b.flock(boids); // uses current control values
      b.update(p.maxSpeed);
      b.edges(canvas.clientWidth, canvas.clientHeight);
      b.draw(ctx, control.vectors.checked);
    }
  }

  // Hook UI buttons
  control.resetBtn.addEventListener('click', () => {
    initBoids(Number(control.count.value));
    control.info.textContent = `Boids: ${control.count.value} • Perception: ${control.perception.value}`;
    // redraw instantly
    ctx.clearRect(0,0,canvas.clientWidth,canvas.clientHeight);
  });

  control.pauseBtn.addEventListener('click', () => {
    running = !running;
    if(running){
      control.pauseBtn.textContent = 'Pause';
      animate();
    } else {
      control.pauseBtn.textContent = 'Resume';
      cancelAnimationFrame(raf);
    }
  });

  control.addBtn.addEventListener('click', () => {
    let v = Number(control.count.value) + 10;
    if(v > Number(control.count.max)) v = Number(control.count.max);
    control.count.value = v; refreshLabels();
    // add 10 boids at random positions
    for(let i=0;i<10;i++) boids.push(new Boid(Math.random()*canvas.clientWidth, Math.random()*canvas.clientHeight));
  });
  control.subBtn.addEventListener('click', () => {
    let v = Math.max(10, Number(control.count.value) - 10);
    control.count.value = v; refreshLabels();
    // remove 10 boids
    boids.splice(0,10);
  });

  control.count.addEventListener('input', () => {
    const desired = Number(control.count.value);
    const diff = desired - boids.length;
    if(diff > 0){
      for(let i=0;i<diff;i++) boids.push(new Boid(Math.random()*canvas.clientWidth, Math.random()*canvas.clientHeight));
    } else if(diff < 0){
      boids.splice(0, -diff);
    }
  });

  // export PNG
  control.pngBtn.addEventListener('click', () => {
    const link = document.createElement('a');
    link.download = 'boids.png';
    link.href = canvas.toDataURL('image/png');
    link.click();
  });

  // init & start
  initBoids(Number(control.count.value));
  running = true;
  animate();

  // keep labels in sync if user changes many controls quickly
  setInterval(refreshLabels, 120);

  // friendly touch: pause on touchstart+hold for mobile (long-press)
  let touchTimer = null;
  canvas.addEventListener('touchstart', (e)=>{
    if(touchTimer) clearTimeout(touchTimer);
    touchTimer = setTimeout(()=>{ control.pauseBtn.click(); }, 500);
  });
  canvas.addEventListener('touchend', ()=>{ if(touchTimer) clearTimeout(touchTimer); touchTimer = null; });

})();
</script>
</body>
</html>
